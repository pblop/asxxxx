.nlist
;****************************************************************************
;
; Include This File To Define The IDE And MFM Registers
;
;	Note:
;		Before this file is included define the accumultaor
;		value for acc/ACC (include the appropriate SFR file)
;		If acc/ACC are not defined then multiple errors will
;		be generated by the .ide.b macro.
;
;****************************************************************************
;
	; Set UPPER_CASE_DEF Non Zero To Define Upper Case IDE/MFM Registers
	; Set LOWER_CASE_DEF Non Zero To Define Lower Case IDE/MFM Registers
	; Else Both Upper And Lower Case IDE Registers Will Be Defined

	.ifeq	UPPER_CASE_DEF + LOWER_CASE_DEF
		UPPER_CASE_DEF =: 1
		LOWER_CASE_DEF =: 1
	.endif

;
;****************************************************************************
;
	; Macro To Define Register Bit Numbers
	; Creates Symbols reg$str7 = acc+7, reg$str6 = acc+6, ..., reg$str0 = acc+0
	.macro	.ide.b	reg, str7, str6, str5, str4, str3, str2, str1, str0
	  ide$n =: acc+7
	  .irp	str, str7, str6, str5, str4, str3, str2, str1, str0
	    .ifnb str
	reg'_'str =: ide$n
	    .endif
	    ide$n = ide$n - 1
	  .endm
	.endm
;
;****************************************************************************
;
.ifne	UPPER_CASE_DEF
	.list	(!,src)
;	ioreg.def       Upper Case IDE          Defined
	.nlist
;
;****************************************************************************
;

	; DMA & IDE Register Offsets

	SCT$SZ  =:	0x0100	; IDE sector size (words)
							 
	DREGLO  =:	0x8000	; R/W	; Low Byte Of 16-Bit Data Port
					; High Byte Of 16-Bit Data Port
					; Is Latched When Low Byte Is Read
							 
	ERRSTS  =:	0x8001  ; RO	; Error Register
		ER.BAD  =:	0x80	; RO Bad Block Bit
		ER.UNC  =:	0x40	; RO Uncorrectable Error Bit
		; ----	=:	0x20	; -- Reserved
		ER.IDN  =:	0x10	; RO Sector ID Not Found
		; ----	=:	0x08	; -- Reserved
		ER.ABT  =:	0x04	; RO Command Aborted Bit
		ER.TNF  =:	0x02	; RO Track '0' Not Found Bit
		ER.DNF  =:	0x01	; RO Address Mark Not Found Bit

	.ide.b	ER,	BAD,	UNC,	,	IDN,	,	ABT,	TNF,	DNF

	FETREG  =:	0x8001  ; WO	; Feature Register
							 
	SCTCNT  =:	0x8002  ; R/W	; Sector Transfer Count Register
	SCTNUM  =:	0x8003  ; R/W	; Starting Sector Register	/ <07:00> Of LBA
	LOCYL   =:	0x8004  ; R/W	; Low  Byte of Cylinder Address / <15:08> Of LBA
	HICYL   =:	0x8005  ; R/W	; High Byte of Cylinder Address / <23:16> Of LBA
							 
	DRVREG  =:	0x8006  ; R/W	; Drive/Head Register
		DR.ST2  =:	0x80	; -- Always '1'
		DR.LBA	=:	0x40	; RO Set To '1' In LBA Mode
		DR.ST1  =:	0x20	; -- Always '1'
		DR.DRV  =:	0x10	; RW Drive Selected Bit
		DR.HS3  =:	0x08	; RW <3:0> Head Select Bits Or
		DR.HS2  =:	0x04	; RW Bits <27:24> Of LBA Address
		DR.HS1  =:	0x02	; RW
		DR.HS0  =:	0x01	; RW

		DR.SET	=:	DR.ST1 | DR.ST2

	.ide.b	DR,	ST2,	LBA,	ST1,	DRV,	HS3,	HS2,	HS1,	HS0

	STSREG  =:	0x8007  ; RO	; IDE Status Register (Clears IRQ)
		ST.BSY  =:	0x80	; RO Drive BSY Bit
		ST.RDY  =:	0x40	; RO Drive Ready Bit
		ST.WF   =:	0x20	; RO Drive Write Fault Bit
		ST.SKC  =:	0x10	; RO Drive Seek Complete Bit
		ST.DRQ  =:	0x08	; RO Drive Request Data Transfer Bit
		ST.CRC  =:	0x04	; RO Correctable Error Encountered Bit
		ST.IND  =:	0x02	; RO Index Pulse Detected Bit
		ST.ERR  =:	0x01	; RO Drive Error Bit

	.ide.b	ST,	BSY,	RDY,	WF,	SKC,	DRQ,	CRC,	IND,	ERR

	CMDREG  =:	0x8007  ; WO	; Drive Command Register
		CM.RES  =:	0x10	; Recalibrate Drive
		CM.RD   =:	0x20	; Read Sector(s)		POIR
		CM.WT   =:	0x30	; Write Sector(s)		PIOW
		CM.WTC  =:	0x32	; Write Sector(s) with CRC	PIOW
		CM.RDV  =:	0x40	; Read/Verify Sector(s)		PIOR
		CM.FMT  =:	0x50	; Format a Track
		CM.SK   =:	0x70	; Seek (Head, Cylinder, Sector)
		CM.PDT  =:	0x90	; Perform diagnostic Tests
		CM.IDP  =:	0x91	; Initialize Drive Parameters
		CM.DMR	=:	0xC8	; Read DMA
		CM.DMW	=:	0xCA	; Write DMA
		CM.IDN  =:	0xEC	; Get Drive Identification
		CM.FET	=:	0xEF	; Set Features
					; Other Optional IDE Commands Not Used
	DREGHI	=:	0x8008	; RW	; Latched High Byte
	DMALO	=:	0x8009	; RW	; DMA Address Bits <7:0>
	DMAHI	=:	0x800A	; RW	; DMA Address Bits <15:8>

	DMASTS	=:	0x800B	; RW	; DMA Status And Control Register
		DM.IRQ	=:	0x80	; RO Interrupt Request
		DM.RST	=:	0x40	; RW Reset Drive When Bit Set / Read As 0
		DM.RDY	=:	0x20	; RO IO Ready
		DM.RQ	=:	0x10	; RO DMA Request
		DM.RW	=:	0x08	; RW DMA Read/Write
		DM.B18	=:	0x04	; RW DMA Address Bit <18>
		DM.B17	=:	0x02	; RW DMA Address Bit <17>
		DM.B16	=:	0x01	; RW DMA Address Bit <16>
							 
		DMA.BNK	=:	0x04	; RW DMA Cache Bank Bit <18>

	.ide.b	DM,	IRQ,	RST,	RDY,	RQ,	RW,	B18,	B17,	B16

	ALTSTS  =:	0x800E  ; RO	; IDE Status Register (Alternate)
;		ST.BSY  =:	0x80	; RO Drive BSY Bit
;		ST.RDY  =:	0x40	; RO Drive Ready Bit
;		ST.WF   =:	0x20	; RO Drive Write Fault Bit
;		ST.SKC  =:	0x10	; RO Drive Seek Complete Bit
;		ST.DRQ  =:	0x08	; RO Drive Request Data Transfer Bit
;		ST.CRC  =:	0x04	; RO Correctable Error Encountered Bit
;		ST.IND  =:	0x02	; RO Index Pulse Detected Bit
;		ST.ERR  =:	0x01	; RO Drive Error Bit

;	.ide.b	ST,	BSY,	RDY,	WF,	SKC,	DRQ,	CRC,	IND,	ERR

	DVCTRL  =:	0x800E  ; WO	; Device Control Register
		; ----	=:	0x80	; XX
		; ----	=:	0x40	; XX
		; ----	=:	0x20	; XX
		; ----	=:	0x10	; XX
		DC.SET  =:	0x08	; WO Always '1'
		DC.RST  =:	0x04	; WO Drive Reset Bit
		DC.EBL  =:	0x02	; WO * Interrupt Enable
		; ----	=:	0x01	; R0 Always '0'

	.ide.b	DC,	,	,	,	,	SET,	RST,	EBL,

	DRVADD  =:	0x800F  ; RO	; Drive Address Register
		DA.HIZ	=:	0x80	; RO High Impedance State
		DA.WTG  =:	0x40	; RO * Disk Write in Progress
		DA.HS3  =:	0x20	; RO * <5:2> Disk Head Select
		DA.HS2  =:	0x10	; RO *
		DA.HS1  =:	0x08	; RO *
		DA.HS0  =:	0x04	; RO *
		DA.DS1  =:	0x02	; RO * Drive 1 Selected
		DA.DS0  =:	0x01	; RO * Drive 0 Selected

	.ide.b	DA,	HIZ,	WTG,	HS3,	HS2,	HS1,	HS0,	DS1,	DS0

.endif
;
;****************************************************************************
;
.ifne	LOWER_CASE_DEF
	.list	(!,src)
;	ioreg.def       Lower Case IDE          Defined
	.nlist
;
;****************************************************************************
;

	; DMA & IDE Register Offsets

	sct$sz  =:	0x0100	; IDE sector size (words)
							 
	dreglo  =:	0x8000	; R/W	; Low Byte Of 16-Bit Data Port
					; High Byte Of 16-Bit Data Port
					; Is Latched When Low Byte Is Read
							 
	errsts  =:	0x8001  ; RO	; Error Register
		er.bad  =:	0x80	; RO Bad Block Bit
		er.unc  =:	0x40	; RO Uncorrectable Error Bit
		; ----	=:	0x20	; -- Reserved
		er.idn  =:	0x10	; RO Sector ID Not Found
		; ----	=:	0x08	; -- Reserved
		er.abt  =:	0x04	; RO Command Aborted Bit
		er.tnf  =:	0x02	; RO Track '0' Not Found Bit
		er.dnf  =:	0x01	; RO Address Mark Not Found Bit
							 
	.ide.b	er,	bad,	unc,	,	idn,	,	abt,	tnf,	dnf

	fetreg  =:	0x8001  ; WO	; Feature Register
							 
	sctcnt  =:	0x8002  ; R/W	; Sector Transfer Count Register
	sctnum  =:	0x8003  ; R/W	; Starting Sector Register	/ <07:00> Of LBA
	locyl   =:	0x8004  ; R/W	; Low  Byte of Cylinder Address / <15:08> Of LBA
	hicyl   =:	0x8005  ; R/W	; High Byte of Cylinder Address / <23:16> Of LBA
							 
	drvreg  =:	0x8006  ; R/W	; Drive/Head Register
		dr.st2  =:	0x80	; Always '1'
		dr.lba	=:	0x40	; RO Set To '1' In LBA Mode
		dr.st1  =:	0x20	; Always '1'
		dr.drv  =:	0x10	; RW Drive Selected Bit
		dr.hs3  =:	0x08	; RW <3:0> Head Select Bits Or
		dr.hs2  =:	0x04	; RW Bits <27:24> Of LBA Address
		dr.hs1  =:	0x02	; RW
		dr.hs0  =:	0x01	; RW

		dr.set	=:	dr.st1 | dr.st2
							 
	.ide.b	dr,	st2,	lba,	st1,	drv,	hs3,	hs2,	hs1,	hs0

	stsreg  =:	0x8007  ; RO	; IDE Status Register (Clears IRQ)
		st.bsy  =:	0x80	; RO Drive BSY Bit
		st.rdy  =:	0x40	; RO Drive Ready Bit
		st.wf   =:	0x20	; RO Drive Write Fault Bit
		st.skc  =:	0x10	; RO Drive Seek Complete Bit
		st.drq  =:	0x08	; RO Drive Request Data Transfer Bit
		st.crc  =:	0x04	; RO Correctable Error Encountered Bit
		st.ind  =:	0x02	; RO Index Pulse Detected Bit
		st.err  =:	0x01	; RO Drive Error Bit

	.ide.b	st,	bsy,	rdy,	wf,	skc,	drq,	crc,	ind,	err

	cmdreg  =:	0x8007  ; WO	; Drive Command Register
		cm.res  =:	0x10	; Recalibrate Drive
		cm.rd   =:	0x20	; Read Sector(s)		POIR
		cm.wt   =:	0x30	; Write Sector(s)		PIOW
		cm.wtc  =:	0x32	; Write Sector(s) with CRC	PIOW
		cm.rdv  =:	0x40	; Read/Verify Sector(s)		PIOR
		cm.fmt  =:	0x50	; Format a Track
		cm.sk   =:	0x70	; Seek (Head, Cylinder, Sector)
		cm.pdt  =:	0x90	; Perform diagnostic Tests
		cm.idp  =:	0x91	; Initialize Drive Parameters
		cm.dmr	=:	0xC8	; Read DMA
		cm.dmw	=:	0xCA	; Write DMA
		cm.idn  =:	0xEC	; Get Drive Identification
		cm.fet	=:	0xEF	; Set Features
					; Other Optional IDE Commands Not Used

	dreghi	=:	0x8008	; RW	; High Byte Of 16-Bit Data Port (latched)
	dmalo	=:	0x8009	; RW	; DMA Address Bits <7:0>
	dmahi	=:	0x800A	; RW	; DMA Address Bits <15:8>

	dmasts	=:	0x800B	; RW	; DMA Status And Control Register
		dm.irq	=:	0x80	; RO Interrupt Request
		dm.rst	=:	0x40	; RW Reset Drive When Bit Set / Read As 0
		dm.rdy	=:	0x20	; RO IO Ready
		dm.rq	=:	0x10	; RO DMA Request
		dm.rw	=:	0x08	; RW DMA Read/Write
		dm.b18	=:	0x04	; RW DMA Address Bit <18>
		dm.b17	=:	0x02	; RW DMA Address Bit <17>
		dm.b16	=:	0x01	; RW DMA Address Bit <16>

		dma.bnk	=:	0x04	; RW DMA Cache Bank Bit <18>

	.ide.b	dm,	irq,	rst,	rdy,	rq,	rw,	b18,	b17,	b16

	altsts  =:	0x800E  ; RO	; IDE Status Register (Alternate)
;		st.bsy  =:	0x80	; RO Drive BSY Bit
;		st.rdy  =:	0x40	; RO Drive Ready Bit
;		st.wf   =:	0x20	; RO Drive Write Fault Bit
;		st.skc  =:	0x10	; RO Drive Seek Complete Bit
;		st.drq  =:	0x08	; RO Drive Request Data Transfer Bit
;		st.crc  =:	0x04	; RO Correctable Error Encountered Bit
;		st.ind  =:	0x02	; RO Index Pulse Detected Bit
;		st.err  =:	0x01	; RO Drive Error Bit
							 
;	.ide.b	st,	bsy,	rdy,	wf,	skc,	drq,	crc,	ind,	err

	dvctrl  =:	0x800E  ; WO	; Device Control Register
		; ----	=:	0x80	; XX
		; ----	=:	0x40	; XX
		; ----	=:	0x20	; XX
		; ----	=:	0x10	; XX
		dc.set  =:	0x08	; WO Always '1'
		dc.rst  =:	0x04	; WO Drive Reset Bit
		dc.ebl  =:	0x02	; WO * Interrupt Enable
		; ----	=:	0x01	; WO Always '0'
							 
	.ide.b	dc,	,	,	,	,	set,	rst,	ebl,

	drvadd  =:	0x800F  ; RO	; Drive Address Register
		da.hiz	=:	0x80	; RO High Impedance State
		da.wtg  =:	0x40	; RO * Disk Write in Progress
		da.hs3  =:	0x20	; RO * <5:2> Disk Head Select
		da.hs2  =:	0x10	; RO *
		da.hs1  =:	0x08	; RO *
		da.hs0  =:	0x04	; RO *
		da.ds1  =:	0x02	; RO * Drive 1 Selected
		da.ds0  =:	0x01	; RO * Drive 0 Selected

	.ide.b	da,	hiz,	wtg,	hs3,	hs2,	hs1,	hs0,	ds1,	ds0

.endif
;
;****************************************************************************
;
.ifne	UPPER_CASE_DEF
	.list	(!,src)
;	ioreg.def       Upper Case MFM          Defined
	.nlist
;
;****************************************************************************
;

	; MFM Controller Registers

	PRTSTS	=:	0x8010	; RW	; Ports Status
		PR.STP4	=:	0x80	; RW Port 4 Stepped		(W To Clear)
		PR.DIR4	=:	0x40	; RO Port 4 Step Direction
		PR.STP3	=:	0x20	; RW Port 3 Stepped		(W To Clear
		PR.DIR3	=:	0x10	; RO Port 3 Step Direction
		PR.STP2	=:	0x08	; RW Port 2 Stepped		(W To Clear)
		PR.DIR2	=:	0x04	; RO Port 2 Step Direction
		PR.STP1	=:	0x02	; RW Port 1 Stepped		(W To Clear)
		PR.DIR1	=:	0x01	; RO Port 1 Step Direction

	.ide.b	PR,	STP4,	DIR4,	STP3,	DIR3,	STP2,	DIR2,	STP1,	DIR1

	HDSTS	=:	0x8011	; RO	; Head Status
		HD.HD3	=:	0x80	; RO Head Select Bit 3
		HD.HD2	=:	0x30	; RO Head Select Bit 2
		HD.HD1	=:	0x20	; RO Head Select Bit 1
		HD.HD0	=:	0x10	; RO Head Select Bit 0
		HD.MHD3	=:	0x08	; RO Mapped Head Select Bit 3
		HD.MHD2	=:	0x04	; RO Mapped Head Select Bit 2
		HD.MHD1	=:	0x02	; RO Mapped Head Select Bit 1
		HD.MHD0	=:	0x01	; RO Mapped Head Select Bit 0

	.ide.b	HD,	HD3,	HD2,	HD1,	HD0,	MHD3,	MHD2,	MHD1,	MHD0

	; Write To TRKWT0 / TRTWT1 With Bits Set Will CLEAR Those Bits

	TRKWT0	=:	0x8012	; RO	; Track Written Register 0
		TRK7	=:	0x80	; RO Track 7  Written To
		TRK6	=:	0x40	; RO Track 6  Written To
		TRK5	=:	0x20	; RO Track 5  Written To
		TRK4	=:	0x10	; RO Track 4  Written To
		TRK3	=:	0x08	; RO Track 3  Written To
		TRK2	=:	0x04	; RO Track 2  Written To
		TRK1	=:	0x02	; RO Track 1  Written To
		TRK0	=:	0x01	; RO Track 0  Written To

	TRKWT1	=:	0x8013	; RO	; Track Written Register 1
		TRK15	=:	0x80	; RO Track 15 Written To
		TRK14	=:	0x40	; RO Track 14 Written To
		TRK13	=:	0x20	; RO Track 13 Written To
		TRK12	=:	0x10	; RO Track 12 Written To
		TRK11	=:	0x08	; RO Track 11 Written To
		TRK10	=:	0x04	; RO Track 10 Written To
		TRK9	=:	0x02	; RO Track 9  Written To
		TRK8	=:	0x01	; RO Track 8  Written To

	MFMSTS	=:	0x8014	; RW	; MFM Status Register
        	MF.CHNG	=:	0x80	; RO Port 1-4 Stepped
		MF.ACTV	=:	0x40	; RO A Port Is Active
		MF.INDX	=:	0x20	; RO Index Pulse (102.4 us)
		MF.WFLT	=:	0x10	; RW Write Fault
		MF.SKDN	=:	0x08	; RO Active Seek Done (Complete)
		MF.TRK0	=:	0x04	; RO Active Track 0 Flag
		MF.BANK	=:	0x02	; RO Active Memory Bank Selected
		MF.RDY	=:	0x01	; RW Drive Ready

	.ide.b	MF,	CHNG,	ACTV,	INDX,	WFLT,	SKDN,	BANK,	TRK0,	RDY

	BTCTRL	=:	0x8015	; WO	; MFM SEEK/TRACK0/BANK Control
		BT.SKWT	=:	0x80	; WO Write Enable SKBIT
		BT.SKBT	=:	0x40	; WO SEEK(PS1:PS0) Bit Value
		BT.TKWT	=:	0x20	; WO Write Enable TKBIT
		BT.TKBT	=:	0x10	; WO TRACK0(PS1:PS0) Bit Value
		BT.BKWT	=:	0x08	; WO Write Enable BKBIT
		BT.BKBT	=:	0x04	; WO BANK(PS1:PS0) Bit Value
		BT.PS1	=:	0x02	; WO Port Select Address Bit 1
		BT.PS0	=:	0x01	; WO Port Select Address Bit 0

	.ide.b	BT,	SKWT,	SKBT,	TKWT,	TKBT,	BKWT,	BKBT,	PS1,	PS0

	ACTPRT	=:	0x8015	; RO	; Active Port Status
		AC.ACTV	=:	0x80	; RO Port Active
		AC.SKDN	=:	0x40	; R0 PORT SEEKDN Status   (PS1:PS0)
		AC.TRK0	=:	0x20	; RO PORT TRACK0 Status   (PS1:PS0)
		AC.BANK	=:	0x10	; RO PORT BANK Bit Status (PS1:PS0)
		AC.PRT4	=:	0x08	; RO Port 4 Active Bit
		AC.PRT3	=:	0x04	; RO Port 3 Active Bit
		AC.PRT2	=:	0x02	; RO Port 2 Active Bit
		AC.PRT1	=:	0x01	; RO Port 1 Active Bit

	.ide.b	AC,	ACTV,	SKDN,	BANK,	TRK0,	PRT4,	PRT3,	PRT2,	PRT1

	X1TBIT	=:	0x8016	; WO	; X1 Test Bit
		X1.BTWT	=:	0x02	; WO Write Enable X1BIT
		X1.BIT0	=:	0x01	; WO X1 Bit Value

	X2TBIT	=:	0x8017	; WO	; X2 Test Bit
		X2.BTWT	=:	0x02	; WO Write Enable X2BIT
		X2.BIT0	=:	0x01	; WO X2 Bit Value

	DRVTYP	=:	0x8017	; WO	; MFM / RLL Drive Type Control
		DR.DTWT	=:	0x80	; WO Write Enable Drive Type
		DR.DTBT	=:	0x40	; WO Drive Type Bit Value

.endif
;
;****************************************************************************
;
.ifne	LOWER_CASE_DEF
	.list	(!,src)
;	ioreg.def       Lower Case MFM          Defined
	.nlist
;
;****************************************************************************
;

	; MFM Controller Registers

	prtsts	=:	0x8010	; RW	; Ports Status
		pr.stp4	=:	0x80	; RW Port 4 Stepped		(W To Clear)
		pr.dir4	=:	0x40	; RO Port 4 Step Direction
		pr.stp3	=:	0x20	; RW Port 3 Stepped		(W To Clear
		pr.dir3	=:	0x10	; RO Port 3 Step Direction
		pr.stp2	=:	0x08	; RW Port 2 Stepped		(W To Clear)
		pr.dir2	=:	0x04	; RO Port 2 Step Direction
		pr.stp1	=:	0x02	; RW Port 1 Stepped		(W To Clear)
		pr.dir1	=:	0x01	; RO Port 1 Step Direction

	.ide.b	pr,	stp4,	dir4,	stp3,	dir3,	stp2,	dir2,	stp1,	dir1

	hdsts	=:	0x8011	; RO	; Head Status
		hd.hd3	=:	0x80	; RO Head Select Bit 3
		hd.hd2	=:	0x30	; RO Head Select Bit 2
		hd.hd1	=:	0x20	; RO Head Select Bit 1
		hd.hd0	=:	0x10	; RO Head Select Bit 0
		hd.mhd3	=:	0x08	; RO Mapped Head Select Bit 3
		hd.mhd2	=:	0x04	; RO Mapped Head Select Bit 2
		hd.mhd1	=:	0x02	; RO Mapped Head Select Bit 1
		hd.mhd0	=:	0x01	; RO Mapped Head Select Bit 0

	.ide.b	hd,	hd3,	hd2,	hd1,	hd0,	mpd3,	mpd2,	mpd1,	mpd0

	; Write To trkwt0 / trtwt1 With Bits Set Will CLEAR Those Bits

	trkwt0	=:	0x8012	; RO	; Track Written Register 0
		trk7	=:	0x80	; RO Track 7  Written To
		trk6	=:	0x40	; RO Track 6  Written To
		trk5	=:	0x20	; RO Track 5  Written To
		trk4	=:	0x10	; RO Track 4  Written To
		trk3	=:	0x08	; RO Track 3  Written To
		trk2	=:	0x04	; RO Track 2  Written To
		trk1	=:	0x02	; RO Track 1  Written To
		trk0	=:	0x01	; RO Track 0  Written To

	trkwt1	=:	0x8013	; RO	; Track Written Register 1
		trk15	=:	0x80	; RO Track 15 Written To
		trk14	=:	0x40	; RO Track 14 Written To
		trk13	=:	0x20	; RO Track 13 Written To
		trk12	=:	0x10	; RO Track 12 Written To
		trk11	=:	0x08	; RO Track 11 Written To
		trk10	=:	0x04	; RO Track 10 Written To
		trk9	=:	0x02	; RO Track 9  Written To
		trk8	=:	0x01	; RO Track 8  Written To

	mfmsts	=:	0x8014	; RW	; MFM Status Register
        	mf.chng	=:	0x80	; RO Port 1-4 Stepped
		mf.actv	=:	0x40	; RO A Port Is Active
		mf.indx	=:	0x20	; RO Index Pulse (102.4 us)
		mf.wflt	=:	0x10	; RW Write Fault
		mf.skdn	=:	0x08	; RO Active Seek Done (Complete)
		mf.trk0	=:	0x04	; RO Active Track 0 Flag
		mf.bank	=:	0x02	; RO Active Memory Bank
		mf.rdy	=:	0x01	; RW Drive Ready

	.ide.b	mf,	chng,	actv,	indx,	wflt,	skdn,	bank,	trk0,	rdy

	btctrl	=:	0x8015	; WO	; MFM SEEK/TRACK0/BANK Bit Control
		bt.skwt	=:	0x80	; WO Write Enable SKBIT
		bt.skbt	=:	0x40	; WO SEEK(PS1:PS0) Bit Value
		bt.tkwt	=:	0x20	; WO Write Enable TKBIT
		bt.tkbt	=:	0x10	; WO TRACK0(PS1:PS0) Bit Value
		bt.bkwt	=:	0x08	; WO Write Enable BKBIT
		bt.bkbt	=:	0x04	; WO BANK(PS1:PS0) Bit Value
		bt.ps1	=:	0x02	; WO Port Select Address Bit 1
		bt.ps0	=:	0x01	; WO Port Select Address Bit 0

	.ide.b	bt,	skwt,	skbt,	tkwt,	tkbt,	bkwt,	bkbt,	ps1,	ps0

	actprt	=:	0x8015	; RO	; Active Port Status
		ac.actv	=:	0x80	; RO Port Active
		ac.skdn	=:	0x40	; R0 PORT SEEKDN Status   (PS1:PS0)
		ac.trk0	=:	0x20	; RO PORT TRACK0 Status   (PS1:PS0)
		ac.bank	=:	0x10	; RO PORT BANK Bit Status (PS1:PS0)
		ac.prt4	=:	0x08	; RO Port 4 Active Bit
		ac.prt3	=:	0x04	; RO Port 3 Active Bit
		ac.prt2	=:	0x02	; RO Port 2 Active Bit
		ac.prt1	=:	0x01	; RO Port 1 Active Bit

	.ide.b	ac,	actv,	skdn,	bank,	trk0,	prt4,	prt3,	prt2,	prt1

	xtbits	=:	0x8016	; WO	; X1/X2 Test Bits
		x2.btwt	=:	0x08	; WO Write Enable X2BIT
		x2.btx2	=:	0x04	; WO X2 Bit Value
		x1.btwt	=:	0x02	; WO Write Enable X1BIT
		x1.btx1	=:	0x01	; WO X1 Bit Value

	drvtyp	=:	0x8017	; WO	; 0 - (MFM 100MHz) / 1 - (RLL 150Mhz)
		dr.dtwt	=:	0x80	; WO Write Enable Drive Type
		dr.dtbt	=:	0x40	; WO Drive Type Bit Value

.endif


